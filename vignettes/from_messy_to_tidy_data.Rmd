---
title: "Awesome title about messy data and how to clean them!"
author: ..., Steffen Ehrmann, Stephan MÃ¤s, Carsten Meyer, Lars Bernard
date: "`r Sys.Date()`"
bibliography: references.bib
fontsize: 12pt
linestretch: 1.15
link-citations: yes
urlcolor: blue
tags:
- integrate
- harmonise
- areal data
- zonal data
- heterogeneous data
- messy data
- tidy data
- ...
# csl: harvard-staffordshire-university.csl
biblio-style: apalike
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{bla}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Reorganising and normalising messy tables

Spreadsheets as places where data tables are recorded can be ridiculously messy.
All thinkable arrangements of the data may be encountered, culminating in several non-uniformly formatted and non-systematically placed tables contained within one spreadsheet.
In `arealDB` each of the individual tables within a spreadsheet is called *cluster*.
A cluster is characterised by an origin, its upper left cell, and by a width and height.

A common best practice of building up data tables is that variables are recorded in columns and observations in rows, so that the data can be considered *tidy* [@Wickham2014] and normalised at least to the third normal form [@Codd1990].
Tidy tables typically contain two kinds of variables

1. Variables that have been measured in some way and that consequently represent the values of that measurement, be they continuous or categorical (they are called *values variables* here).
2. Variables that identify the unit for which the values have been measured (they are called *identifying (or id) variables* here).

These two variable types are the target variables in `arealDB`.
The primary aim of reorganising messy tables lays in determining where those two kinds of variables are located in each cluster.
In the context of areal data the variables *administrative territories* and the *period*, which identify observational units, make up the backbone of any database.

Some tables contain the names of values variables as another supposed identifying variable.
Those are, however, not tidy tables because the name-bearing column is neither an identifying variable, nor a values variable.
Such a table constitutes a \"long\" table that comprises a *key-values pair* (the column containing the supposed \"identifier\" and that containing the values this identifier refers to), which needs to be spread to a \"wide\" table (described in detail below).

The following sections each start with a description of the table that needs reshaping, followed by a brief description of how this table needs to be reshaped and the schema description that is used for the reorganisation.
In the first section only the arrangement of clusters is discussed, while the following sections describe how the contents of each cluster can be re-arranged.
This is definitely not an exhaustive list of possible table arrangements, but it should cover the most common cases and be extensible enough to capture many mutations of the presented tables.
The final section contains a list of steps that should be taken one after the other to come up with a schema description.

## Spreadsheet contains (several) clusters

Clusters are often of the same arrangement within one spreadsheet, they can be repeated along rows (horizontally) or along columns (vertically).
A table should be treated like a cluster also when the spreadsheet contains not only the table, but perhaps also text that may be scattered across the document and that does not allow the table to start at the spreadsheet origin in the topmost left cell.

To reorganise the data into tidy form, each cluster is \"cut out\", rearranged individually and appended to the end of an output table.

**Horizontal clusters**<br>
In case horizontal clusters are sitting right next to each other in the same origin row (Tab. \@ref(tab:table1)), it is sufficient to provide the topmost row and all leftmost columns at which a new cluster starts.
In case there is some arbitrary horizontal space between clusters, also the width (of each cluster) needs to be provided.

| territories | commodities | harvested | production | commodities | harvested | production |
| :- | :- | :- | :- | :- | :- | :- |
|  | year 1 |  |  | year 2 |  |  |
| unit 1 | soybean | 1111 | 1112 | soybean | 1211 | 1212 |
| unit 1 | maize | 1121 | 1122 | maize | 1221 | 1222 |
| ... |  |  |  |  |  |  |

Table: (\#tab:table1) Horizontal clusters of the identifying variable `period`.

```{r, eval=FALSE}
list(clusters = list(top = 1, left = c(2, 5), width = NULL, height = NULL,
                     id = "period"),
     variables = list(territories = 
                        list(type = "id", name = NULL, form = "long",
                             row = NULL, col = 1, rel = FALSE),
                      period = 
                        list(type = "id", name = "year", form = "wide",
                             row = 1, col = NULL, rel = FALSE),
                      ...))
```
<br>
**Vertical clusters**<br>
For vertically arranged clusters (Tab. \@ref(tab:table2)), just like for the horizontal case, the respective rows, columns and heights need to be provided.

|  | territories | commodities | harvested | production |
| :- | :- | :- | :- | :- |
| year 1 |  |  |  |  |
|  | unit 1 | soybean | 1111 | 1112 |
|  | unit 1 | maize | 1121 | 1122 |
|  | ... |  |  |  |
| year 2 |  |  |  |  |
|  | unit 1 | soybean | 1211 | 1212 |
|  | unit 1 | maize | 1221 | 1222 |
|  | ... |  |  |  |

Table: (\#tab:table2) Vertical clusters of the identifying variable `period`.

```{r, eval=FALSE}
list(clusters = list(top = c(1, ...), left = 1, width = NULL, height = NULL,
                     id = "period"),
     variables = list(territories = 
                        list(type = "id", name = NULL, form = "long",
                             row = NULL, col = 2, rel = TRUE),
                      period = 
                        list(type = "id", name = "year", form = "long",
                             row = NULL, col = 1, rel = TRUE),
                      ...))
```
<br>
**Messy clusters**<br>
In case several clusters are neither aligned along a row nor a column, and are all of differing size, the respective information need to be provided at the same index of the respective property.
For example, three clusters, where the first cluster starts at (1,1) and is 3 by 4 cells in size, where the second clusters starts at (5,2) and is 5 by 5 cells in size, and so on, needs to be specified as below.

```{r, eval=FALSE}
list(clusters = list(top = c(1, 5, 1), left = c(1, 2, 5), 
                     width = c(3, 5, 2), height = c(4, 5, 3),
                     id = "period"),
     variables = list(territories = 
                        list(type = "id", name = NULL, form = "long",
                             row = NULL, col = 2, rel = TRUE),
                      period = 
                        list(type = "id", name = "year", form = "long",
                             row = NULL, col = 1, rel = TRUE),
                      ...))
```
<br>
Additionally, given that at least the tables within each cluster are all arranged in the same way, the contained variables can be specified so that their row and column indices are given relative to the cluster position (`rel = TRUE`).
If also that is not the case, the row and column values for each cluster need to be provided for the respective variables in the same way as for cluster positions. 

## Long table

In case a table contains all identifying variables in columns, including the variable names of a values variable, while the values are presented in only one column, we typically have a \"long\" table (Tab. \@ref(tab:table3)).
To end up with tidy data the column `dimension` needs to be spread into all levels that can be found in it, `harvested` and `production`.

| territories | period | commodities | dimension | values |
| :- | :- | :- | :- | :- |
| unit 1 | year 1 | soybean | harvested | 1111 |
| unit 1 | year 1 | maize | harvested | 1121 |
| unit 1 | year 1 | soybean | production | 1112 |
| unit 1 | year 1 | maize | production | 1122 |
| unit 1 | year 2 | soybean | harvested | 1211 |
| unit 1 | year 2 | maize | harvested | 1221 |
| unit 1 | year 2 | soybean | production | 1212 |
| unit 1 | year 2 | maize | production | 1222 |
| ... |  |  |  |  |

Table: (\#tab:table3) The variable names of the target variable are treated as if they were an identifying variable.

```{r, eval=FALSE}
list(clusters = list(top = NULL, left = NULL, width = NULL, height = NULL,
                     id = NULL),
     variables = list(territories = 
                        list(type = "id", name = NULL, form = "long",
                             row = NULL, col = 1, rel = FALSE),
                      # all of the variables are in 'long' form, including the
                      # target variable names. These need to be spread so that
                      # the values variables are in their own column.
                      period = 
                        list(type = "id", name = "year", form = "long",
                             row = NULL, col = 2, rel = FALSE),
                      commodities =
                        list(type = "id", name = NULL, form = "long",
                             row = NULL, col = 3, rel = FALSE),
                      # the fifth column contains values for all levels of its
                      # id variable (in this case 'dimension').
                      harvested = 
                        list(type = "values", unit = "ha", factor = 1,
                             row = NULL, col = 5, rel = FALSE, 
                             id = "dimension", level = "harvested"),
                      production = 
                        list(type = "values", unit = "t", factor = 1,
                             row = NULL, col = 5, rel = FALSE, 
                             id = "dimension", level = "production")))
```

## The target variables are in individual columns

In case the target variables are arranged into individual columns (Tab. \@ref(tab:table4)), we have tidy data [@Wickham2014], which are already in the correct arrangement of `arealDB`.
The variables in a tidy table may merely need different names and units and transformation factors need to be recorded.

| territories | period | commodities | harvested | production |
| :- | :- | :- | :- | :- |
| unit 1 | year 1 | soybean | 1111 | 1112 |
| unit 1 | year 1 | maize | 1121 | 1122 |
| unit 1 | year 2 | soybean | 1211 | 1212 |
| unit 1 | year 2 | maize | 1221 | 1222 |
| unit 2 | year 1 | soybean | 2111 | 2112 |
| unit 2 | year 1 | maize | 2121 | 2122 |
| unit 2 | year 2 | soybean | 2211 | 2212 |
| unit 2 | year 2 | maize | 2221 | 2222 |
| ... |  |  |  |  |

Table: (\#tab:table4) A tidy table.

```{r, eval=FALSE}
list(clusters = list(top = NULL, left = NULL, width = NULL, height = NULL,
                     id = NULL),
     variables = list(territories = 
                        list(type = "id", name = NULL, form = "long",
                             row = NULL, col = 1, rel = FALSE),
                      # the first and second column contain the indispensable
                      # 'id' variables. In 'row' and 'col' the upper left cell
                      # of the data is given and when this is NULL, it means the
                      # whole col/row is meant.
                      period = 
                        list(type = "id", name = "year", form = "long",
                             row = NULL, col = 2, rel = FALSE),
                      # in the third column commodities are given, an
                      # optional 'id' variable that is specific for the
                      # example use-case.
                      commodities = 
                        list(type = "id", name = NULL, form = "long",
                             row = NULL, col = 3, rel = FALSE),
                      harvested = 
                        list(type = "values", unit = "ha", factor = 1, 
                             row = NULL, col = 4, rel = FALSE, 
                             id = NULL, value = NULL),
                      production = 
                        list(type = "values", unit = "t", factor = 1, 
                             row = NULL, col = 5, rel = FALSE, 
                             id = NULL, value = NULL)))
```

## (Several) identifying variables are in wide form

Identifying variables may be treated as if they were variable names.
It could be argued that a table is in the correct format when not the measured variable, but one of the identifying variables is given as values variable.
For instance, compare Tab. \@ref(tab:table5) with Tab. \@ref(tab:table4).
Table \@ref(tab:table5) looks just like a valid table, however `harvested` and `production` are not observational units, while `soybean` and `maize` are not measured variables, so that this would not constitute tidy data.

| territories | period | dimension | soybean | maize |
| :- | :- | :- | :- | :- |
| unit 1 | year 1 | harvested | 1111 | 1112 |
| unit 1 | year 1 | production | 1121 | 1122 |
| unit 1 | year 2 | harvested | 1211 | 1212 |
| unit 1 | year 2 | production | 1221 | 1222 |
| ... |  |  |  |  |

Table: (\#tab:table5) The identifying variable `commodities` is treated as if it were the observed variable.

```{r, eval=FALSE}
list(clusters = list(top = NULL, left = NULL, width = NULL, height = NULL,
                     key = NULL),
     variables = list(territories = 
                        list(type = "id", name = NULL, form = "long"
                             row = NULL, col = 1, rel = FALSE),
                      period = 
                        list(type = "id", name = "year", form = "long",
                             row = NULL, col = 2, rel = FALSE),
                      dimension =
                        list(type = "id", name = NULL, form = "long",
                             row = NULL, col = 3, rel = FALSE),
                      # the commodities are spread over two columns and thus the
                      # variable is "wide".
                      commodities = 
                        list(type = "id", name = NULL, form = "wide",
                             row = 1, col = c(4, 5), rel = FALSE),
                      # after rearranging, "dimension" is a long variable, which
                      # also needs to be adapted.
                      harvested = 
                        list(type = "values", unit = "ha", factor = 1,
                             row = NULL, col = 3, rel = FALSE, 
                             id = "dimension", value = "harvested"),
                      production = 
                        list(type = "values", unit = "t", factor = 1,
                             row = NULL, col = 3, rel = FALSE, 
                             id = "dimension", value = "harvested")))
```
<br>
Wide identifying variables may even be \"nested\" within values variables (Tab. \@ref(tab:table6)) or within other identifying variables (Tab. \@ref(tab:table7)). In those cases all columns that contain data of the same variable are provided to the specification of that variable.

| territories | period | harvested |  | production |  |	
| :- | :- | :- | :- | :- | :- |
|  |  | soybean | maize | soybean | maize |
| unit 1 | year 1 | 1111 | 1121 | 1211 | 1221 |
| unit 1 | year 2 | 1112 | 1122 | 1212 | 1222 |
| unit 2 | year 1 | 2111 | 2121 | 2112 | 2122 |
| unit 2 | year 2 | 2211 | 2221 | 2212 | 2222 |
| ... |  |  |  |  |  |

Table: (\#tab:table6) The identifying variable `commodities` is nested within the target variable.

```{r, eval=FALSE}
list(clusters = list(top = NULL, left = NULL, width = NULL, height = NULL,
                     key = NULL),
     variables = list(territories = 
                        list(type = "id", name = NULL, form = "long"
                             row = NULL, col = 1, rel = FALSE),
                      period = 
                        list(type = "id", name = "year", form = "long",
                             row = NULL, col = 2, rel = FALSE),
                      commodities = 
                        list(type = "id", name = NULL, form = "wide",
                             row = 2, col = NULL, rel = FALSE),
                      harvested = 
                        list(type = "values", unit = "ha", factor = 1,
                             row = NULL, col = c(3, 4), rel = FALSE, 
                             id = NULL, value = NULL),
                      production = 
                        list(type = "values", unit = "t", factor = 1,
                             row = NULL, col = c(5, 6), rel = FALSE, 
                             id = NULL, value = NULL)))
```
<br>

| territories | year 1 |  |  |  | year 2 |  |  |  |
| :- | :- | :- | :- | :- | :- | :- | :- | :- |
|  | soybean |  | maize |  | soybean |  | maize |  |
|  | harvested | production | harvested | production | harvested | production | harvested | production |
| unit 1 | 1111 | 1112 | 1121 | 1122 | 1211 | 1212 | 1221 | 1222 |
| unit 2 | 2111 | 2211 | 2121 | 2221 | 2112 | 2212 | 2122 | 2222 |
| ... |  |  |  |  |  |  |  |  |

Table: (\#tab:table7) The identifying variable `commodities` is nested in the identifying variable `period`. The target variable is spread across those nested columns.

```{r, eval=FALSE}
list(clusters = list(top = NULL, left = NULL, width = NULL, height = NULL,
                     key = NULL),
     variables = list(territories = 
                        list(type = "id", name = NULL, form = "long"
                             row = NULL, col = 1, rel = FALSE),
                      period = 
                        list(type = "id", name = "year", form = "wide",
                             row = 1, col = c(2, 6), rel = FALSE),
                      commodities = 
                        list(type = "id", name = NULL, form = "wide",
                             row = 2, col = c(2, 4, 6, 8), rel = FALSE),
                      # here 'dimension' is an implicit variable that is
                      # recorded in row 3, we thus need to register it in our
                      # schema description.
                      dimension =
                        list(type = "id", name = NULL, form = "wide",
                             row = 3, col = NULL, rel = FALSE),
                      harvested = 
                        list(type = "values", unit = "ha", factor = 1,
                             row = NULL, col = c(2, 4, 6, 8), rel = FALSE, 
                             id = "dimension", value = NULL),
                      production = 
                        list(type = "values", unit = "t", factor = 1,
                             row = NULL, col = c(3, 5, 7, 9), rel = FALSE, 
                             id = "dimension", value = NULL)))
```

## Setting up schema descriptions

A schema description shall be composed according to the following rules:

1. Clarify which are the identifying variables and which are the values variables.
2. Determine whether there are clusters and find the origin (top left cell) of each cluster (Tabs. \@ref(tab:table1) & \@ref(tab:table2)). Follow the next steps for each cluster...
3. Determine whether a table can be separated into a \"long\" and an \"other\" part. The long part would consist of columns that contain identifying variables that do not need to be rearranged and the other part would contain data that need to be rearranged.
4. Find the column index of all identifying variables,
    * if identifying variables are wide, additionally find their row index (Tab. \@ref(tab:table7)).
5. Find the column index of all values variables, 
    * if a variable is spread over several columns, write down all columns for that particular variable (Tab. \@ref(tab:table6)).
6. If the names of values variables are given as an identifying variable, give that column name as `id` of the values variable, together with the respective term (`value`) of the values variables (Tab. \@ref(tab:table5)) (this indicates that this *key-values pair* must be spread).
    * if the names of values variables are not given as column names, but spread across a particular row, register a variable that describes the values variables and use that variable in the `id` of the values variable (Tab. \@ref(tab:table7)).
7. Determine unit and transformation factor for each values variable.

## Session Information
```{r session info}
sessionInfo()
```


# References


