---
title: "tabshiftr - Reshape disorganised messy data"
output: 
  bookdown::html_document2:
    fig_caption: yes
    number_sections: yes
    theme: spacelab
    highlight: pygments
    toc: yes
    toc_float: yes
bibliography: references.bib
urlcolor: blue
fontsize: 12pt
linestretch: 1.15
link-citations: yes
vignette: >
  %\VignetteIndexEntry{reorganising messy data}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
options(knitr.kable.NA = '.')
library(tabshiftr)
library(knitr)
```

# Rationale

Tables as places where data tables are recorded can be pretty messy.
The 'tidy' paradigm in R proposes that data are organised so that variables are recorded in columns, observations in rows and that there is only one value per cell [@Wickham2014].
This, however, is only one interpretation of how data should be organised and especially when scraping data from multiple heterogeneous sources, one frequently encounters messy data that don't follow this paradigm.

The `tidyr` package is one of the most popular tools to bring data into a tidy format. 
However, up until today it is limited to tables that are already organised into topologically coherent (rectangular) chunks.
In `tabshiftr` we try to describe and work with a further dimension of messiness, where data are available as so-called *disorganised (messy) data*, data that are not yet arranged into rectangular form.

# The basics

Data can be disorganised according to multiple dimensions.
To understand those dimensions, we first need to understand the nature of data.
Data \"of the same kind\" are collected in a **variable**, which is always a combination of a **name** and the **values**. 
In a table, names are typically in the topmost row and values are in the column below that name ([Tab. 1](#tabExample1)).
Conceptually, there are two types of variables in any table:

1. Variables that contain categorical levels that identify the units for which values have been observed (they are called *identifying variables* here).
2. Variables that have been measured or observed and that consequently represent the target values of that measurement, be they continuous or categorical (they are called *observed variables* here).

Moreover, a table is part of a **series** when other tables of that series contain the same variables, irrespective of how the distinct tables of that series are arranged.

| identifying variable | observed variable (categorical) | observed variable (continuous) |
| :- | :- | :- |
| sample 1 | blue | 10 |
| sample 1 | green | 20 |
| sample 1 | red | 30 |

Table: <a name="tabExample1"></a>Table 1: An example table containing one identifying and two observed variables, with the variable names in the topmost row and the values in all consecutive rows.

Even though data in many spreadsheet are \"disorganised\", they are mostly not non-systematic. Especially in complex spreadsheets, one often encounters a situation where a set of variables occurs more than once with the same or very similar organisation, which we call **cluster** here. Data that are part of clusters are split up by another, typically categorical variable (the **cluster ID**), with the aim to increase the visual accessibility or direct the focus for human readers ([Tab. 2](#tabExample2)). This may also be the case where data are split up across several files or spreadsheets of a file, where the cluster ID can be found in the file or spreasheet name or the meta-data. In that case, the cluster ID would be an **implicit variable** that needs to be recorded as such.

| sample | colour | intensity | sample | colour | intensity |
| :- | :- | :- | :- | :- | :- |
| sample 1 |  |  | sample 2 |  |  |
|  | blue | 10 |  | blue | 11 |
|  | green | 20 |  | green | 24 |
|  | red | 30 |  | red | 13 |
|  |  |  |  |  |  |
| sample 3 |  |  | sample 4 |  |  |
|  | blue | 20 |  | blue | 10 |
|  | green | 15 |  | green | 16 |
|  | red | 33 |  | red | 21 |

Table: <a name="tabExample2"></a>Table 2: An example of a table with several clusters of comparable variables.

<!-- ## Dimensions of disorganisation -->

<!-- Several of the following dimensions of disorganisation can co-occur in one table. -->
<!-- Examples of each of them are presented in the section [Table types](#table-types). -->

<!-- 1) Each level of an identifying variable, or a categorical observed variable are organised into separate topologically coherent chunks (clusters) of data, instead of all variables in one cluster/table. -->
<!-- 2) The names of several observed variables are treated as if they were the levels of an identifying variable (they are *listed*), instead of each observed variable in its own column. This is also called \"long\" data. -->
<!-- 3) The levels of one or more identifying variable are spread over several columns, instead of all levels in only one column. This is also called \"wide\" data. -->
<!-- 4) Several identifying variables are stored in the same column or one identifying variable is split up into several columns. -->
<!-- 5) A table is organised so that one or more variables are \"not in one piece\" (e.g., empty rows and/or columns). -->
<!-- 6) One or more variables are merely implicitly available (e.g., as table or file name or in a \"meta-data header\") -->
<!-- 7) Tables that are part of the same series (i.e., that contain the same variables), contain variables in different columns in each table. -->
<!-- 8) Some columns of a particular chunk are missplaced vertically or some rows are missplaced horizontally so that variables and observations don't match across the whole table (not yet explicitly solved here). -->


# How to make a schema description

The approach of `tabshiftr` is based on capturing the arrangement of a table in a so-called  [schema](https://en.wikipedia.org/wiki/Database_schema) description.
Typically there is an input and an output schema, describing the arrangement of the input and output tables, respectively.
The advantage of this procedure is that input and output tables exist explicitly and the schema maps the transformation of the data.
As we want to end up with tidy tables, the output schema is pre-determined by a tidy table of the included variables.
The input schema description, however,  needs to be provided by the user.

To set up a schema description, the following steps should be taken:

1. **Variables**: Clarify which are the identifying variables and which are the observed variables. Make sure not to mistake a listed observed variable as an identifying variable. 

2. **Meta-data**: Provide potentially information about the table format (`setFormat()`).

3. **Clusters**: Determine the following:

    - are the data clustered at all and if so, find the origin (top left cell) of each cluster and provide the required information in `setCluster(top = ..., left = ...)` ([Tab. 9](#clusHor), [Tab. 10](#clusId) & [Tab. 11](#clusMeas)).  
    - clarify whether data are clustered according to an identifying variable, or whether observed variables are grouped into clusters:
      * in case data are clustered according to an identifying variable, specify that identifying variable (`setIDVar()`) and give its name in `setCluster(id = ...)` ([Tab. 9](#clusHor), [Tab. 10](#clusId)).
      * in case the observed variables are grouped into clusters, provide simply `"observed"` in `setCluster(id = ...)` ([Tab. 11](#clusMeas)).
    - are clusters nested into a grouping variable of interest and if so, specify that variable in `setCluster(group = ...)`, give the group index to which each cluster belongs in `member = ...` and specify the group ID as an identifying variable (`setIDVar()`) ([Tab. 13](#clustPar)).
    - in case the data split up into several files or spreadsheets, identify the implicit variable, provide it as cluster ID and provide the value associated to the current table in `setIDVar(value = ...)` ([Tab. 6](#implicitVar)).
    <br><br>

4. **Identifying variables**: Determine the following:

    - all columns in which the variable values can be found.
    - in case the variable is wide (i.e., its values are in several columns), determine additionally the row in which the values can be found. In this case, the values will look like they are part of the header ([Tab. 4](#nest2)).
    - in case the variable must be split off of another column, provide a regular expression that results in the target subset via `setIDVar(..., split = ...)` ([Tab. 5](#splitCol)).
    - in case the variable is distinct from the main table, provide the explicit (non-relative) position and set `setIDVar(..., distinct = TRUE)` ([Tab. 12](#distVar)).
    <br><br>
    
5. **Observed variable**: Determine the following:

    - all columns in which the values of the variable can be found ([Tab. 7](#long)).
    - the unit and conversion factor.
    - in case the variable is not tidy, go through the following cases one after the other:
        * in case the variable is nested in a wide identifying variable, determine in addition to the columns in which the values can be found also the rows in which the **variable name** can be found ([Tab. 3](#nest1) & [Tab. 4](#nest2)).
        * in case the names of the variable are given as a value of an identifying variable ([Tab. 8](#wideLong)), give the column name as `key`, together with the name of the respective observed variable (as it appears in the table) in `values`.
        * in case the name of the variable is the ID of clusters, specify `key = "cluster"` and in `values` the cluster number the variable refers to ([Tab. 11](#clusMeas)).
    <br><br>

# Table types

In this section we look at some examples of disorganised data, discuss the dimension along which they are disorganised and show which schema description should be used to reorganise them.

To work with `tabshiftr`, tables need to be read in while treating any header rows *as data*, i.e., by not setting the first row as header, because in disorganised tables it's often not only the first row that is part of the header. 
Moreover, each column should be treated as a character data type, because some columns might contain data with both numeric and character cells.
`reorganise()` takes care of reformatting the data into the most permissive data type that does not introduce `NA`s where there should be data, i.e, if a variable can be numeric, it is formatted as numeric column.

```{r, eval=F}
input <- read_csv(...,
                  col_names = FALSE,
                  col_types = cols(.default = "c"))
```

All of the following examples contain an `other_observed`, an `empty_col` column and an empty row, which serve the purpose of dummy information or formating that could be found in any table and should not disturb the process of reorganising.
You can run all the examples by simply loading the schema and calling `reorganise(input = tabs2shift$..., schema = schema)` with the respective table that is plotted for this example.

## Table contains one cluster

### Tidy table

In case the observed variables are arranged into individual columns ([Tab. 3](#tabTidy)), we have tidy data [@Wickham2014], which are largely already in the target arrangement.
The tidy table may however, still contain unneeded data, need different names, or transformation factors for the values.

```{r}
kable(tabs2shift$tidy)
```

Table: <a name="tabTidy"></a>Table 3: A largely tidy table.


```{r}
schema <-
  setIDVar(name = "territories", columns = 1) %>%
  setIDVar(name = "year", columns = 2) %>%
  setIDVar(name = "commodities", columns = 3) %>%
  setObsVar(name = "harvested", columns = 5) %>%
  setObsVar(name = "production", columns = 6, factor = 0.1)

reorganise(input = tabs2shift$tidy, schema = schema)
```


### Mismatch of columns and variables

Sometimes it may be the case that number variables is not the same as there are columns because either one variable is spread over several column, or one column contains several variables.

In the former case, columns need to be merged ([Tab. 4](#splitCol)) and in the latter case, columns need to be split via [regular expressions](https://edrub.in/CheatSheets/cheatSheetStringr.pdf) ([Tab. 5](#mergeCol)).
For example, `.+?(?=_)` gives everything up until the first `_` and `(?<=\\_).*` everything after the `_ `.

```{r}
kable(input <- tabs2shift$split_column)
```

Table: <a name="mergeCol"></a>Table 4: The variables `year` is split up into two columns.

```{r, eval=FALSE}
schema <-
  setIDVar(name = "territories", columns = 1) %>%
  setIDVar(name = "year", columns = c(2, 4), merge = " ") %>%
  setIDVar(name = "commodities", columns = 5) %>%
  setObsVar(name = "harvested", columns = 6) %>%
  setObsVar(name = "production", columns = 7)
```

```{r}
kable(tabs2shift$merged_column)
```

Table: <a name="splitCol"></a>Table 5: The variables `year` and `commodities` are stored in the same column.

```{r, eval=FALSE}
schema <- setHeader(rows = 1) %>%
  setIDVar(name = "territories", columns = 1) %>%
  setIDVar(name = "year", columns = 2, split = ".+?(?=_)") %>%
  setIDVar(name = "commodities", columns = 2, split = "(?<=\\_).*") %>%
  setObsVar(name = "harvested", unit = "ha", columns = 3) %>%
  setObsVar(name = "production", unit = "t", columns = 4)
```


### Implicit variables

When data are split up into clusters that are stored in separate files or spreadsheets, the cluster ID is often recorded not in the table as an explicit variable, but is only provided in the file or table name.
In those cases, we have to register the this cluster ID as an identifying variable nevertheless, to output a consistent table.

```{r}
kable(input <- tabs2shift$implicit_variable)
```

Table: <a name="implicitVar"></a>Table 6: The information about which territory we are dealing with is missing or implied by some meta-data.

```{r, eval=FALSE}
schema <- setCluster(id = "territories",
                     left = 1, top = 4) %>%
  setIDVar(name = "territories", value = "unit 1") %>%
  setIDVar(name = "year", columns = 4) %>%
  setIDVar(name = "commodities", columns = 1) %>%
  setObsVar(name = "harvested", columns = 2) %>%
  setObsVar(name = "production", columns = 3)
```


### Wide variables


In case identifying variables are factors with a small number of levels, those levels may falsely be used as names of other variables, where they would be next to each other and thus \"wide\" ([Tab. 7](#one_wide_id)).
Those other variables (both identifying and observed variables) would then be \"nested\" in the wide identifying variables.
In those cases we have to record for the identifying variable(s) the columns **and the row** in which the values of the identifying variable are found. For the observed variable(s) we need to record also the columns and the topmost row of that variable, i.e., the row in which the name of the nested observed variable is found.

```{r}
kable(input <- tabs2shift$one_wide_id)
```

Table: <a name="one_wide_id"></a>Table 7: The observed variables are nested within the identifying variable `commodities`.

```{r, eval=FALSE}
schema <-
  setIDVar(name = "territories", columns = 1) %>%
  setIDVar(name = "year", columns = 3) %>%
  setIDVar(name = "commodities", columns = c(4, 6), rows = 1) %>%
  setObsVar(name = "harvested", columns = c(4, 6), top = 2) %>%
  setObsVar(name = "production", columns = c(5, 7), top = 2)
```

The same is also true in case the identifying variables are actually nested within the observed variables, i.e., the names of the observed variables are on top of the names of the id variables ([Tab. 8](#wide_obs)). However, if an observed variables is in the topmost row, `top = 1` can be omitted.

```{r}
kable(input <- tabs2shift$wide_obs)
```

Table: <a name="wide_obs"></a>Table 8: The identifying variable `commodities` is nested within the observed variables.


```{r, eval=FALSE}
schema <-
  setIDVar(name = "territories", columns = 1) %>%
  setIDVar(name = "year", columns = 2) %>%
  setIDVar(name = "commodities", columns = c(3:6), rows = 2) %>%
  setObsVar(name = "harvested", columns = c(3, 4)) %>%
  setObsVar(name = "production", columns = c(5, 6))
```


In case several variables are nested within other variables, we have to specify for all nested or nesting variables in which rows their values sit and adapt the header.

```{r}
kable(input <- tabs2shift$two_wide_id)
```

Table: <a name="wide_obs"></a>Table 9: The observed variables are nested within the identifying variable `year` and `commodities`.


```{r, eval=FALSE}
schema <-
  setIDVar(name = "territories", columns = 1) %>%
  setIDVar(name = "year", columns = c(2, 6), rows = 1) %>%
  setIDVar(name = "commodities", columns = c(2, 4, 6, 8), rows = 2) %>%
  setObsVar(name = "harvested", columns = c(2, 4, 6, 8), top = 3) %>%
  setObsVar(name = "production", columns = c(3, 5, 7, 9), top = 3)
```


### Listed *observed variables*

Some tables contain a column where the names of observed variables (`harvested` and `production`) are treated as if they were the values of an identifying variable (`dimension`), while the values are presented in only one column (`values`) ([Tab. 10](#long)).
To end up with tidy data in those cases, we need to extract the values associated with the observed variables.
Thus, we define the observed variables and specify the `key = ` in which the variable names sit, and the `value = ` the variable name has, to extract that variable.

```{r}
kable(input <- tabs2shift$listed_column)
```

Table: <a name="long"></a>Table 10: The variable names of the observed variable are treated as if they were the values of the identifying variable `dimension`.


```{r, eval=FALSE}
schema <-
  setIDVar(name = "territories", columns = 1) %>%
  setIDVar(name = "year", columns = 2) %>%
  setIDVar(name = "commodities", columns = 3) %>%
  setObsVar(name = "harvested", columns = 7, key = 6, value = "harvested") %>%
  setObsVar(name = "production", columns = 7, key = 6, value = "production")
```

Moreover, (several) identifying variables may be wide additionally and we have to proceed as mentioned above, by providing the columns and the rows of the variable values (which appear to be names).

```{r}
kable(input <- tabs2shift$listed_column_wide)
```

Table: <a name="wideLong"></a>Table 11: The identifying variable `commodities` is treated as if it were the observed variables while the variable names of the observed variable are treated as if they were the values of the identifying variable `dimension`.


```{r, eval=FALSE}
schema <-
  setIDVar(name = "territories", columns = 1) %>%
  setIDVar(name = "year", columns = 2) %>%
  setIDVar(name = "commodities", columns = c(6, 7), rows = 1) %>%
  setObsVar(name = "harvested", columns = c(6, 7), key = 4, value = "harvested") %>%
  setObsVar(name = "production", columns = c(6, 7), key = 4, value = "production")
```


### Missplaced columns or rows

WIP


## Table contains several clusters

Clusters are typically of the same arrangement within one table, they can be repeated along rows (horizontally) or along columns (vertically), but also a non-systematic distribution is possible.
Moreover, clusters may be nested into some grouping variable in a similar way that data are nested into clusters.
A table could also be treated like a cluster when the table is not only composed of the table, but perhaps also text in the form of some table description (that may be scattered in the document and) that does not allow the table to start at the table origin in the topmost left cell.

To reorganise those data into tidy form, each cluster is \"cut out\", rearranged individually and appended to the end of an output table by `reorganise()`.

### Horizontal clusters

In case clusters are sitting right next to each other in the same origin row ([Tab. 9](#clusHor)), it is sufficient to provide the topmost row and all leftmost columns at which a new cluster starts.
In case there is some arbitrary horizontal space between clusters, also the width (of each cluster) needs to be provided.


| X1 | X2 | X3 | X4 | X5 | X6 | X7 |
| :- | :- | :- | :- | :- | :- | :- |
| period | commodities | harvested | production | commodities | harvested | production |
|  | unit 1 |  |  | unit 2 |  |  |
| year 1 | soybean | 1111 | 1112 | soybean | 2111 | 2112 |
| year 1 | maize | 1121 | 1122 | maize | 2121 | 2122 |
| year 2 | soybean | 1211 | 1212 | soybean | 2211 | 2212 |
| year 2 | maize | 1221 | 1222 | maize | 2221 | 2222 |

Table: <a name="clusHor"></a>Table 9: Horizontal clusters of the identifying variable `period`.

```{r, eval=FALSE}
schema <- setCluster(id = "territories", left = c(2, 5), top = 2) %>%
  setHeader(rows = 1) %>%
  setIDVar(name = "territories", columns = c(2, 5), row = 2) %>%
  setIDVar(name = "year", columns = 1) %>%
  setIDVar(name = "commodities", columns = c(2, 5)) %>%
  setObsVar(name = "harvested", columns = c(3, 6), unit = "ha") %>%
  setObsVar(name = "production", columns = c(4, 7), unit = "t")
```


### Vertical clusters

For vertically arranged clusters ([Tab. 10](#clusId)), just like for the horizontal case, the respective rows, columns (and heights) need to be provided.

| X1 | X2 | X3 | X4 | X5 |
| :- | :- | :- | :- | :- |
| territories | period | commodities | harvested | production |
| unit 1 |  |  |  |  |     
|  | year 1 | soybean | 1111 | 1112 |
|  | year 1 | maize | 1121 | 1122 |
|  | year 2 | soybean | 1211 | 1212 |
|  | year 2 | maize | 1221 | 1222 |
| unit 2 |  |  |  |  |
|  | year 1 | soybean | 2111 | 2112 |
|  | year 1 | maize | 2121 | 2122 |
|  | year 2 | soybean | 2211 | 2212 |
|  | year 2 | maize | 2221 | 2222 |

Table: <a name="clusId"></a>Table 10: Vertical clusters of the identifying variable `period`.

```{r, eval=FALSE}
schema <- setCluster(id = "territories", top = c(3, 8), left = 2) %>%
  setHeader(rows = 1) %>%
  setIDVar(name = "territories", columns = 1, row = c(2, 7)) %>%
  setIDVar(name = "year", columns = 2) %>%
  setIDVar(name = "commodities", columns = 3) %>%
  setObsVar(name = "harvested", columns = 4, unit = "ha") %>%
  setObsVar(name = "production", columns = 5, unit = "t")
```


### Clusters of observed variables

The previous two types of clusters are clusters of identifying variables, but it may also be the case that the observed variables are split up into distinct clusters.
Here, we need to specify first of all `setClusters(..., id = "observed")` to indicate that the observed variable is the cluster ID.
Next, we need to set up the observed variables so that they contain `"key = "cluster"` and in `value` the number of the cluster this variable can be found in.
Moreover, we provide the column(s) and all rows that contain the values of each observed variable.
This is in contrast to nested observed variables, where the rows of the variable names need to be provided.

| X1 | X2 | X3 | X4 | X5 |
| :- | :- | :- | :- | :- |
|  | territories | period | commodities | values |
| harvested |  |  |  |  |
|  | unit 1 | year 1 | soybean | 1111 |
|  | unit 1 | year 1 | maize | 1121 |
|  | unit 1 | year 2 | soybean | 1211 |
|  | unit 1 | year 2 | maize | 1221 |
|  | unit 2 | year 1 | soybean | 2111 |
|  | unit 2 | year 1 | maize | 2121 |
|  | unit 2 | year 2 | soybean | 2211 |
|  | unit 2 | year 2 | maize | 2221 |
| production |  |  |  |  |
|  | unit 1 | year 1 | soybean | 1112 |
|  | unit 1 | year 1 | maize | 1122 |
|  | unit 1 | year 2 | soybean | 1212 |   
|  | unit 1 | year 2 | maize | 1222 |
|  | unit 2 | year 1 | soybean | 2112 |
|  | unit 2 | year 1 | maize | 2122 |
|  | unit 2 | year 2 | soybean | 2212 |
|  | unit 2 | year 2 | maize | 2222 |

Table: <a name="clusMeas"></a>Table 11: Vertical clusters of the observed variables.

```{r, eval=FALSE}
schema <- setCluster(id = "observed", left = 2, top = c(3, 12), height = 8) %>%
  setHeader(rows = 1) %>%
  setIDVar(name = "territories", columns = 2) %>%
  setIDVar(name = "year", columns = 3) %>%
  setIDVar(name = "commodities", columns = 4) %>%
  setObsVar(name = "harvested", columns = 5, unit = "ha",
            key = "cluster", value = 1) %>%
  setObsVar(name = "production", columns = 5, unit = "t",
            key = "cluster", value = 2)
```


### Clusters that are nested into another variable

When (some) clusters are nested in such a way that their group information is also a variable of interest, not only the cluster positions need to be specified, but also their relation to the grouping variable.
Similar to the cluster ID, this group ID also needs to be specified as an identifying variable and needs to be provided as `group = ...` and the membership of each cluster to a group needs to be specified in `member = ...`. 
The cluster position needs to be specified just as it would be without groups.

| X1 | X2 | X3 | X4 | X5 |
| :- | :- | :- | :- | :- |
| territory | commodities | harvested | production | year |
| region 1 |  |  |  |  |
| unit 1 |  |  |  |  |
|  | soybean | 1111 | 1112 | year 1 |
|  | maize | 1121 | 1122 | year 1 |
|  | soybean | 1211 | 1212 | year 2 |
|  | maize | 1221 | 1222 | year 2 |
| unit 2 |  |  |  |  |
|  | soybean | 2111 | 2112 | year 1 |
|  | maize | 2121 | 2122 | year 1 |
|  | soybean | 2211 | 2212 | year 2 |
|  | maize | 2221 | 2222 | year 2 |
| region 2 |  |  |  |  |
| unit 3 |  |  |  |  |
|  | soybean | 3111 | 3112 | year 1 |
|  | maize | 3121 | 3122 | year 1 |
|  | soybean | 3211 | 3212 | year 2 |
|  | maize | 3221 | 3222 | year 2 |

Table: <a name="clustPar"></a>Table 13: Clusters are grouped according to a variable of interes that should also be captured.

```{r, eval=FALSE}
schema <- setCluster(id = "territories", group = "regions", member = c(1, 1, 2),
                     left = 1, top = c(3, 8, 14)) %>%
    setHeader(rows = 1) %>%
    setIDVar(name = "regions", columns = 1, rows = c(2, 13)) %>%
    setIDVar(name = "territories", columns = 1, rows = c(3, 8, 14)) %>%
    setIDVar(name = "year", columns = 5) %>%
    setIDVar(name = "commodities", columns = 2) %>%
    setObsVar(name = "harvested", columns = 3, unit = "ha") %>%
    setObsVar(name = "production", columns = 4, unit = "t")
```


### Variables that are distinct from a cluster

When not all identifying variables can be provided relative to the cluster origin, for example because they are missing for some clusters, it makes more sense to define such a variable as a distinct variable.
This is done by providing `row` and `col` as absolute values and setting `distinct = TRUE`.
Other variables that are all arranged in the same way in each cluster can be specified so that their row and column indices are given relative to the cluster position (`relative = TRUE`).


| X1 | X2 | X3 | X4 | X5 | X6 | X7 |
| :- | :- | :- | :- | :- | :- | :- |
| commodities | harvested | production  |  |  |  |
| unit 1 |  |  |  |  |  |  |
| soybean | 1111 | 1112 | year 1 |  |  |  |
| maize | 1121 | 1122 | year 1 |  |  |  |
| soybean | 1211 | 1212 | year 2 |  |  |  |
| maize | 1221 | 1222 | year 2 |  |  |  |
|  |  |  |  |  |  |  |
| commodities | harvested | production | commodities | harvested | production |  |
| unit 2 |  |  | unit 3 |  |  |  |
| soybean | 2111 | 2112 | soybean | 3111 | 3112 | year 1 |
| maize | 2121 | 2122 | maize | 3121 | 3122 | year 1 |
| soybean | 2211 | 2212 | soybean | 3211 | 3212 | year 2 |
| maize | 2221 | 2222 | maize | 3221 | 3222 | year 2 |

Table: <a name="distVar"></a>Table 12: Several clusters where one variable is not available for each cluster, but distinct of them.

```{r, eval=FALSE}
schema <- setCluster(id = "territories", top = c(1, 8, 8), left = c(1, 1, 4),
                     width = 3, height = 6) %>%
  setHeader(rows = 1, relative = TRUE) %>%
  setIDVar(name = "territories", columns = 1, row = 2, relative = TRUE) %>%
  setIDVar(name = "year", columns = 4, row = c(3:6), distinct = TRUE) %>%
  setIDVar(name = "commodities", columns = 1, relative = TRUE) %>%
  setObsVar(name = "harvested", unit = "ha", columns = 2, relative = TRUE) %>%
  setObsVar(name = "production", unit = "t", columns = 3, relative = TRUE)
```


### Messy clusters

In case several clusters are neither aligned along a row nor a column, and are all of differing size, the respective information need to be provided at the same index of the respective property.
For example, three clusters, where the first cluster starts at (1,1) and is 3 by 4 cells in size, where the second clusters starts at (5,2) and is 5 by 5 cells in size, and so on, needs to be specified as below.

```{r, eval=FALSE}
schema <- setCluster(top = c(1, 5, 1), left = c(1, 2, 5), 
                     width = c(3, 5, 2), height = c(4, 5, 3), id = ...) %>% 
  setHeader(rows = 1) %>% 
  setIDVar(name = "territories", columns = 1, relative = TRUE) %>% 
  ...
```

Additionally, given that at least the tables within each cluster are all arranged in the same way, the contained variables can be specified so that their row and column indices are given relative to the cluster position (`relative = TRUE`).
If also that is not the case, the row and column values for each cluster need to be provided for the respective variables in the same way as for cluster positions.




# References